package webrtc

import (
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"

	"github.com/webitel/wlog"
)

type (
	SessionDescription = webrtc.SessionDescription
	ICEServer          = webrtc.ICEServer
	PeerConnection     = webrtc.PeerConnection
)

type API interface {
	NewPeerConnection(configuration webrtc.Configuration) (*webrtc.PeerConnection, error)
}

type ICESettings struct {
	DisconnectedTimeout time.Duration
	FailedTimeout       time.Duration
	KeepAliveInterval   time.Duration
}

type PortRange struct {
	Min uint16
	Max uint16
}

type Settings struct {
	Codecs                []string
	ICE                   *ICESettings
	EphemeralUDPPortRange *PortRange
}

func NewApi(log *wlog.Logger, cfg *Settings) API {
	var err error
	mediaEngine := &webrtc.MediaEngine{}

	s := webrtc.SettingEngine{}
	if cfg.ICE != nil {
		s.SetICETimeouts(cfg.ICE.DisconnectedTimeout, cfg.ICE.FailedTimeout, cfg.ICE.KeepAliveInterval)
		log.Debug(fmt.Sprintf("set ice timeouts: disconnect: %v, failed: %v, keep-alive: %v", cfg.ICE.DisconnectedTimeout,
			cfg.ICE.FailedTimeout, cfg.ICE.KeepAliveInterval))
	}

	// TODO DisableActiveTCP ?
	// s.DisableActiveTCP(false)
	s.SetIPFilter(func(ip net.IP) bool {
		return ip.To4() != nil
	})

	if cfg.EphemeralUDPPortRange != nil && cfg.EphemeralUDPPortRange.Min != 0 && cfg.EphemeralUDPPortRange.Max != 0 {
		err = s.SetEphemeralUDPPortRange(cfg.EphemeralUDPPortRange.Min, cfg.EphemeralUDPPortRange.Max)
		if err != nil {
			panic(err.Error())
		}
		log.Debug(fmt.Sprintf("set udp port range: %v/%v", cfg.EphemeralUDPPortRange.Min, cfg.EphemeralUDPPortRange.Max))
	}

	var payloadType webrtc.PayloadType = 97

	for _, v := range cfg.Codecs {
		var typeCodec webrtc.RTPCodecType
		if strings.HasPrefix(v, "audio") {
			typeCodec = webrtc.RTPCodecTypeAudio
		} else if strings.HasPrefix(v, "video") {
			typeCodec = webrtc.RTPCodecTypeVideo
		} else {
			panic("unsupported codec")
		}

		if err = mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
			RTPCodecCapability: webrtc.RTPCodecCapability{
				MimeType:     v,
				ClockRate:    90000,
				Channels:     0,
				SDPFmtpLine:  "",
				RTCPFeedback: nil,
			},
			PayloadType: payloadType,
		}, typeCodec); err != nil {
			panic(err)
		}
		log.Debug(fmt.Sprintf("register codec: %s (PayloadType=%d)", v, payloadType))
		payloadType--
	}

	registry := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		panic(err)
	}
	registry.Add(intervalPliFactory)

	// Use the default set of Interceptors
	if err = webrtc.RegisterDefaultInterceptors(mediaEngine, registry); err != nil {
		panic(err)
	}

	return webrtc.NewAPI(
		webrtc.WithSettingEngine(s),
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithInterceptorRegistry(registry))
}
